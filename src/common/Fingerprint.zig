//! A 256-bit UID generator that should produce unique ids,
//! even when generated by separate devices at the same time. `*`
//!
//! `*` No warranty for this claim :P
const Fingerprint = @This();

const std = @import("std");

threadlocal var thread_prng: std.Random.DefaultPrng = .init(std.mem.bytesToValue(u64, "ribbon<3"));

value: u256,

pub fn init(noise: []const u8) Fingerprint {
    var timestamp: u128 = undefined;
    var prng = std.Random.DefaultPrng.init(std.hash.Murmur2_64.hash(noise));

    var basis = [4]u32 {
        @truncate(std.process.getBaseAddress()),
        thread_prng.random().int(u32),
        b: {
            timestamp = @bitCast(std.time.nanoTimestamp());
            break :b prng.random().int(u32);
        },
        @truncate(std.Thread.getCurrentId()),
    };

    const basisBytes = std.mem.asBytes(&basis);
    thread_prng.random().shuffle(u8, basisBytes);

    const upper: u256 = @as(u256, timestamp) << 128;
    const lower: u256 = std.mem.bytesToValue(u128, &basisBytes);

    return .{ .value = upper | lower };
}

pub fn format(self: *const Fingerprint, comptime _: []const u8, _: std.fmt.FormatOptions, writer: anytype) !void {
    try std.base64.url_safe.Encoder.encodeWriter(writer, std.mem.asBytes(&self.value));
}
